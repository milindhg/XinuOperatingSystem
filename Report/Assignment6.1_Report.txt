Assignment 5

>Problem 9.1:
Write a function that walks the list of free memory blocks and prints a line with the address and length of each block.

We write a new shell command called walkfreemem.
In this function we traverse through the memlist and print each free block's address and length.
We use a traversal pointer of type memblk called curr to traverse through the memlist and the attribute mlength to print the lenght of free block while we use the attribute mnext to move to the next free block.

>Problem 9.4
Replace the low-level memory management functions with a set of functions that allocate heap and stack memory permanently (i.e., without providing a mechanism to return storage to a free list). How do the sizes of the new allocation routines compare to the sizes of getstk and getmem?

We define a new system call called getmemory which will only allocate memory but not pass the handler which can be used to free up the memory allocated by getmemory.
We also define a new shell command called consumememory to demonstrate the use of getmemory and show that the memory is only allocated but not deallocated.
Since in getmemory only heap space is allocated, we also implement a new flag attribute in procent structure to note our process and set the flag. In our process execution, we set the flag. Now when  our process is about to exit, the kill system call will internally check whether the flag is set, then it will not call the freestk function to free up stack space. Thus we can consume both heap and stack space and not free heap and stack and thus see its effect on the available free memory.

First we execute walkfreemem command and note the current free blocks and space.
Then we execute the consumememory to consume some memory (heap and stack)
Then we execute walkfreemem again to note the change the available free memory.
We can see the the avaialble memory is reduced since it is not freed up after allocation during the execution of consumememory.

>>Comparison of the sizes as requested in the problem 9.4

>Problem 9.7
Many embedded systems go through a prototype stage, in which the system is built on a general platform, and a final stage, in which minimal hardware is designed for the system. In terms of memory management, one question concerns the size of the stack needed by each process. Modify the code to allow the system to measure the maximum stack space used by a process and report the maximum stack size when the process exits.


Group Members: 
Milind Gokhale - Programming the consumememory walkfreemem implementation.
Renuka Deshmukh - Programming the getmaxstklen implementation.

