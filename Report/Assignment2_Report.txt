>Does your program output any garbage? If yes, why?
Yes, the program gives garbage output. There are two threads (producer, consumer) in the program which have a shared variable n. However, both the threads are not synchronized and hence access the variable in any order. Since both the threads are accessing and reading the variable in a random order, they output the variable value out of sequence and hence it looks like garbage since the printed lines are not output in synchronized manner.

>Are all the produced values getting consumed? Check your program for a small count like 20.
Below is the output of prodcons 20.
xsh $ prodcons 20
count is 20
produced : 0
produced : 1
produced : 2
produced : 3
produced : 4
produced : 5
produced : 6
produced : 7
produced : 8
produced : 9
produced : xsh $ 1c0
prodouced : n11
prosduced :u 12
prmoduced e: 13
pdroduced  : 14
1produce d : 15
 produc0ed : 16
produ
     ced : 1c7
prodouced : n18
prosduced :u 19
prmoduced e: 20
d : 17

All the values are not consumed by the consumer. In the above output it appears that consumer consumed only 2 values - 0 and 17.
This happens because producer seems to be faster than the consumer. By the time consumer consumes one element, producer already updates the variable many times.


>Functions in the project:
Use of create system call
	create system call creates a thread and returns the thread ID or error in case of issues while creating thread.
	Create system call signature
	/**
	 * @ingroup threads
	 *
	 * Create a thread to start running a procedure.
	 *
	 * @param procaddr
	 *      procedure address
	 * @param ssize
	 *      stack size in bytes
	 * @param priority
	 *      thread priority (0 is lowest priority)
	 * @param name
	 *      name of the thread, used for debugging
	 * @param nargs
	 *      number of arguments that follow
	 * @param ...
	 *      arguments to pass to thread procedure
	 * @return
	 *      the new thread's thread id, or ::SYSERR if a new thread could not be
	 *      created (not enough memory or thread entries).
	 */
	tid_typ create(void *procaddr, uint ssize, int priority,
				   const char *name, int nargs, ...)
	( create(producer, 1024, 20, "producer", 1, count) );

	
Use of resume system call
	resume system call resumes a thread or changes the thread state from SUSPENDED to RUNNING.
	Resume system call signature
	/**
	 * @ingroup threads
	 *
	 * Unsuspend a thread, making it ready
	 * @param tid target thread
	 * @return priority
	 */
	syscall resume(tid_typ tid)

	resume( create(producer, 1024, 20, "producer", 1, count) );

	
xsh_prodcons command: 
	shellcmd xsh_prodcons(int nargs, char *args[])
producer function: 
	void producer(int count);
consumer function: 
	void consumer(int count);

